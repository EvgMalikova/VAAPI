\doxysection{Pipeline}\label{md_doc_molecule_pipeline_autotoc_md8}
\doxysection{Scene creation}\label{md_doc_molecule_pipeline_autotoc_md9}
Below is the example of how such dynamic scene can be constructed with V\+A\+A\+PI 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} Scene\_create(vaRenderer\&ren)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{comment}{/*}}
\DoxyCodeLine{\textcolor{comment}{    *Reading dynamic electron density and electrostatic potential fields data: initial and final state}}
\DoxyCodeLine{\textcolor{comment}{    */}}
\DoxyCodeLine{    \textcolor{comment}{/*<Basic file reader of scalar field data on structural grid, those output is an SDF Texture Sampler*/}}
\DoxyCodeLine{    \textcolor{comment}{/* Reading electron density field, in the initial state, before geometry optimisation*/}}
\DoxyCodeLine{    sdfTextureReader<float> readSDFTex1; }
\DoxyCodeLine{    readSDFTex1.SetContext(m.GetOutput());}
\DoxyCodeLine{    readSDFTex1.SetSize(139, 150, 160);}
\DoxyCodeLine{    readSDFTex1.SetThreshold(0.1);\textcolor{comment}{/*<defines field isosurface that will define the molecule boundary*/}}
\DoxyCodeLine{    readSDFTex1.Setfile(\textcolor{stringliteral}{"ed1.txt"});}
\DoxyCodeLine{    readSDFTex1.Update();}
\DoxyCodeLine{    \textcolor{comment}{/* Reading electron density field, in the final state, after geometry optimisation*/}}
\DoxyCodeLine{    sdfTextureReader<float> readSDFTex2;}
\DoxyCodeLine{    readSDFTex2.SetContext(m.GetOutput());}
\DoxyCodeLine{    readSDFTex2.SetSize(138, 150, 160);}
\DoxyCodeLine{    readSDFTex2.SetThreshold(0.1);}
\DoxyCodeLine{    readSDFTex2.Setfile(\textcolor{stringliteral}{"ed2.txt"});}
\DoxyCodeLine{    readSDFTex2.Update();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/*<Basic file reader of scalar field data on structural grid, those output is an optix Texture Sampler*/}}
\DoxyCodeLine{    \textcolor{comment}{/* Reading electrostatic potential field, in the initial state, before geometry optimisation*/}}
\DoxyCodeLine{    texReader<float> readR1;}
\DoxyCodeLine{    readR1.SetContext(m.GetOutput());}
\DoxyCodeLine{    readR1.SetSize(139, 150, 160);}
\DoxyCodeLine{    readR1.Setfile(\textcolor{stringliteral}{"p1.txt"});}
\DoxyCodeLine{    readR1.Update();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/* Reading electrostatic potential field, in the final state, after geometry optimisation*/}}
\DoxyCodeLine{    texReader<float> readR2; }
\DoxyCodeLine{    readR2.SetContext(m.GetOutput());}
\DoxyCodeLine{    readR2.SetSize(138, 150, 160);}
\DoxyCodeLine{    readR2.Setfile(\textcolor{stringliteral}{"p2.txt"});}
\DoxyCodeLine{    readR2.Update();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/* Creating a dynamic sdf primitive on GPU, representing molecule boundary, described with electron density field}}
\DoxyCodeLine{\textcolor{comment}{    *The primitive properties are automatically set to static/dynamic, depending on 1 or more input textures are}}
\DoxyCodeLine{\textcolor{comment}{    *set with sdfTexture::SetTexture function}}
\DoxyCodeLine{\textcolor{comment}{    */}}
\DoxyCodeLine{    sdfTexture tex; }
\DoxyCodeLine{    tex.SetContext(m.GetOutput());}
\DoxyCodeLine{    tex.SetTexture(readSDFTex1.GetTexture(), readSDFTex1.GetParam());}
\DoxyCodeLine{    tex.SetTexture(readSDFTex2.GetTexture(), readSDFTex1.GetParam());}
\DoxyCodeLine{    tex.Update();}
\DoxyCodeLine{}
\DoxyCodeLine{    BasicLight l1;}
\DoxyCodeLine{    l1.color = optix::make\_float3(1.0);}
\DoxyCodeLine{    l1.pos = optix::make\_float3(1.0);}
\DoxyCodeLine{}
\DoxyCodeLine{    BasicLight l2;}
\DoxyCodeLine{    l2.color = optix::make\_float3(1.0);}
\DoxyCodeLine{    l2.pos = optix::make\_float3(0, 0, 1.0);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/*A general material, that implements rendering of two scalar fields in following modes:}}
\DoxyCodeLine{\textcolor{comment}{    * -\/Emission-\/absorption optical model for Volume Rendering with transfer function that }}
\DoxyCodeLine{\textcolor{comment}{    *  highlights the internal structure of both electron density and electrostaric potential fields}}
\DoxyCodeLine{\textcolor{comment}{    *}}
\DoxyCodeLine{\textcolor{comment}{    * -\/Colors geometry surface with mapped to color values of  electrostaric potential field}}
\DoxyCodeLine{\textcolor{comment}{    * }}
\DoxyCodeLine{\textcolor{comment}{    *The material property is automatically set to static/dynamic, depending on 1 or more input textures are}}
\DoxyCodeLine{\textcolor{comment}{    *set with vaEAVolume::SetTexture function}}
\DoxyCodeLine{\textcolor{comment}{    */}}
\DoxyCodeLine{   }
\DoxyCodeLine{    vaEAVolume texMaterial; }
\DoxyCodeLine{    texMaterial.SetContext(m.GetOutput());}
\DoxyCodeLine{    texMaterial.AddLight(\&l1);}
\DoxyCodeLine{    texMaterial.AddLight(\&l2);}
\DoxyCodeLine{    texMaterial.SetSDFProg(tex.GetCallableProg()); \textcolor{comment}{/*<Gets sdf primitive optix callable program reference for static/dynamic description of SDF field*/}}
\DoxyCodeLine{    texMaterial.SetType(vaEAVolume::MaterialType::VOLUME); \textcolor{comment}{/*<Volume rendering mode*/}}
\DoxyCodeLine{    texMaterial.SetTexture(readR1.GetTexture());}
\DoxyCodeLine{    texMaterial.SetTexture(readR2.GetTexture());}
\DoxyCodeLine{    texMaterial.Update();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/* Mapper, simillar to vtkMapper*/}}
\DoxyCodeLine{    vaMapper map2;}
\DoxyCodeLine{    map2.SetContext(m.GetOutput());}
\DoxyCodeLine{    map2.SetDescInput(tex.GetOutputDesc());}
\DoxyCodeLine{    map2.AddMaterial(texMaterial.GetOutput(), texMaterial.GetType());}
\DoxyCodeLine{    map2.Update();}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{comment}{/*Actor, simillar to vtkActor*/}}
\DoxyCodeLine{    optixSdfActor acSdf;}
\DoxyCodeLine{    acSdf.SetContext(m.GetOutput()); }
\DoxyCodeLine{    acSdf.AddMapper(\&map2);}
\DoxyCodeLine{    acSdf.Update();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/*Add actor to the rendere*/}}
\DoxyCodeLine{    ren.AddActor(\&acSdf);}
\DoxyCodeLine{    \}}
\end{DoxyCode}
\doxysection{Interface implementation for interactive/dynamic rendering}\label{md_doc_molecule_pipeline_autotoc_md10}
The above scene is generated within the following main program 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int} main\_tutor(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[])}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keywordtype}{int}  windowWidth = 512;}
\DoxyCodeLine{    \textcolor{keywordtype}{int}  windowHeight = 512;}
\DoxyCodeLine{}
\DoxyCodeLine{    PinholeCamera pinholeCamera; \textcolor{comment}{//creates basic camera}}
\DoxyCodeLine{}
\DoxyCodeLine{    contextManager m;}
\DoxyCodeLine{    m.Update();\textcolor{comment}{//creates context}}
\DoxyCodeLine{}
\DoxyCodeLine{    vaRenderer ren;}
\DoxyCodeLine{    ren.SetValid(m.GetValid());}
\DoxyCodeLine{    ren.SetContext(m.GetOutput());}
\DoxyCodeLine{}
\DoxyCodeLine{    ren.SetOpticalDims(windowWidth, windowWidth);}
\DoxyCodeLine{    ren.SetCamera(\&pinholeCamera);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//set not dynamic}}
\DoxyCodeLine{    ren.SetDynamic(\textcolor{keyword}{false});}
\DoxyCodeLine{    ren.SetAuditory(\textcolor{keyword}{false});}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//window procedure}}
\DoxyCodeLine{}
\DoxyCodeLine{    GLFW\_Window optixWindowProc;}
\DoxyCodeLine{}
\DoxyCodeLine{    optixWindowProc.SetDim(windowWidth, windowHeight);}
\DoxyCodeLine{    optixWindowProc.SetRenderer(\&ren);}
\DoxyCodeLine{    optixWindowProc.SetContext(m.GetOutput()); \textcolor{comment}{//returns context}}
\DoxyCodeLine{    optixWindowProc.SetCamera(\&pinholeCamera);}
\DoxyCodeLine{}
\DoxyCodeLine{    RenderWindowInteractor iren; \textcolor{comment}{//TODO always check that basic still works}}
\DoxyCodeLine{    iren.SetWindow(\&optixWindowProc);}
\DoxyCodeLine{}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"DONE WITH WINDOW"} << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{    }
\DoxyCodeLine{        \textcolor{keywordflow}{if} (iren.SetUp()) \textcolor{comment}{//everything is ok}}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} accumulation\_frame = 0; \textcolor{comment}{//for progressive rendering}}
\DoxyCodeLine{       \textcolor{keywordflow}{try}}
\DoxyCodeLine{        \{}
\DoxyCodeLine{        Scene\_Create(ren);}
\DoxyCodeLine{        \}}
\DoxyCodeLine{       \textcolor{comment}{/*}}
\DoxyCodeLine{\textcolor{comment}{       * set callback data}}
\DoxyCodeLine{\textcolor{comment}{       */}}
\DoxyCodeLine{        Render::CallbackData cb = \{ (g\_app.m\_pinholeCamera).get(), \&(g\_app.ren), accumulation\_frame \};}
\DoxyCodeLine{        glfwSetWindowUserPointer(optixWindowProc.GetOutput(), \&cb);}
\DoxyCodeLine{        \textcolor{comment}{/* }}
\DoxyCodeLine{\textcolor{comment}{        *set user defined key callback}}
\DoxyCodeLine{\textcolor{comment}{        */}}
\DoxyCodeLine{        iren.SetKeyCallback(keyCallback);}
\DoxyCodeLine{        g\_app.Init(); \textcolor{comment}{//scene creation}}
\DoxyCodeLine{                       \textcolor{comment}{// Main loop}}
\DoxyCodeLine{        iren.Start();}
\DoxyCodeLine{    \}}
\end{DoxyCode}
 Let us consider more in details the key\+Callback procedure. In the current implementation, the va\+Renderer can operate in the following modes, defined in \doxyref{va\+Basic\+Renderer}{p.}{classva_basic_renderer}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{enum} vaBasicRenderer::RenderModes \{}
\DoxyCodeLine{        INTERACTIVE\_CAMERA, \textcolor{comment}{/*<Mode by default. Rendering through defined camera with interactive manipulation}}
\DoxyCodeLine{\textcolor{comment}{                            of its parameter (pan, zoom, etc.). In this mode the optix context launches rendering}}
\DoxyCodeLine{\textcolor{comment}{                            of optical model. In this mode only scene geometry and optic materials are rendered.}}
\DoxyCodeLine{\textcolor{comment}{                            See vaBasicRenderer::LaunchOpticContext() function*/}}
\DoxyCodeLine{}
\DoxyCodeLine{        COMPUTE\_SOUND, \textcolor{comment}{/*<Auditory ray-\/casting. In this mode the optix context launches rendering}}
\DoxyCodeLine{\textcolor{comment}{                       of optical model. See vaBasicRenderer::LaunchAudioContext() function.}}
\DoxyCodeLine{\textcolor{comment}{                       The result of procedure is the computed by ray-\/casting auditory properties}}
\DoxyCodeLine{\textcolor{comment}{                       defined with scene geometry and auditory materials and configured on host OpenAL}}
\DoxyCodeLine{\textcolor{comment}{                       auditory scene representation ready for playing  : set of sound sources,}}
\DoxyCodeLine{\textcolor{comment}{                       sampled sound waves, configured HRTF and etc.}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{                       If the following scene was computed, it would be automatically played if the RenderModes::PLAY\_ANIMATION}}
\DoxyCodeLine{\textcolor{comment}{                       is activated}}
\DoxyCodeLine{\textcolor{comment}{                       */}}
\DoxyCodeLine{}
\DoxyCodeLine{        PLAY\_ANIMATION,  \textcolor{comment}{/*<Rendering of visual-\/auditory dynamic scene. */}}
\DoxyCodeLine{}
\DoxyCodeLine{        INTERACTIVE\_WIDGET  \textcolor{comment}{/*<Interactive manipulation through assigned widget. The widgets are similar to VTK widgets and are used for}}
\DoxyCodeLine{\textcolor{comment}{                            interactive definition of various optical/geometry/auditory parameters, that are considered once the renderer}}
\DoxyCodeLine{\textcolor{comment}{                            */}}
\DoxyCodeLine{    \};}
\end{DoxyCode}


To render the dynamic scene we just need to activate the va\+Basic\+Renderer\+::\+Render\+Modes\+::\+P\+L\+A\+Y\+\_\+\+A\+N\+I\+M\+A\+T\+I\+ON mode in the assigned key callback procedure below. The Render\+Window\+Interactor will read va\+Rendere modes and initiate according procedures of renderer to perfor visual/auditory or dynamic scene ray-\/casting.

Below the example of key\+Callback(\+G\+L\+F\+Wwindow$\ast$ window, int key, int scancode, int action, int mods) procedure that gets renderer through Render\+::\+Callback\+Data.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{namespace }Render \{}
\DoxyCodeLine{    \textcolor{keyword}{struct }CallbackData}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        vaRenderer* ren;}
\DoxyCodeLine{      }
\DoxyCodeLine{    \};}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} keyCallback(GLFWwindow* window, \textcolor{keywordtype}{int} key, \textcolor{keywordtype}{int} scancode, \textcolor{keywordtype}{int} action, \textcolor{keywordtype}{int} mods)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keywordtype}{bool} handled = \textcolor{keyword}{false};}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (action == GLFW\_PRESS)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordflow}{switch} (key)}
\DoxyCodeLine{        \{}
\DoxyCodeLine{        \textcolor{keywordflow}{case}(GLFW\_KEY\_S):}
\DoxyCodeLine{        \{}
\DoxyCodeLine{            Render::CallbackData* cab = static\_cast<Render::CallbackData*>(glfwGetWindowUserPointer(window));}
\DoxyCodeLine{            \textcolor{keywordflow}{if}(cab-\/>ren-\/>isDynamic())\{}
\DoxyCodeLine{            std::cout << \textcolor{stringliteral}{"Playing the dynamic scene"} << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{            cab-\/>ren-\/>SetMode(vaBasicRenderer::RenderModes::PLAY\_ANIMATION);}
\DoxyCodeLine{            cab-\/>ren-\/>SetTime(0.0); \textcolor{comment}{/*<Set initial time to 0*/}}
\DoxyCodeLine{            \textcolor{keywordflow}{break};}
\DoxyCodeLine{            }
\DoxyCodeLine{            }
\DoxyCodeLine{        \}}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{keywordflow}{if} (!handled) \{}
\DoxyCodeLine{        \textcolor{comment}{// forward key event to imgui}}
\DoxyCodeLine{        ImGui\_ImplGlfw\_KeyCallback(window, key, scancode, action, mods);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\end{DoxyCode}
 Dynamic rendering is presented in video ...

The described above multisensory pip 